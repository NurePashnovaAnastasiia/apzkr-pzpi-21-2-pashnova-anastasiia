Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління закладами харчування

Студент гр. ПЗПІ-21-2
__________________ Пашньова А. К.
(підпис)
Керівник роботи
__________________ доц. Лещинський В.О.
(підпис)

Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:
__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.

    Харківський національний університет радіоелектроніки
    
Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6			        ____        
Навчальна дисципліна Архітектура програмного забезпечення	
    
    ЗАВДАННЯ
    НА КУРСОВУ РОБОТУ СТУДЕНТА
    Пашньовій Анастасії Костянтинівні
1. Тема роботи: «Програмна система для управління закладами харчування»	
2. Термін узгодження завдання курсової роботи «26» лютого 2024 р.
3. Термін здачі студентом закінченої роботи «30» червня 2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити:
Додавання до системи заклад харчування, меню, страви; оформлення замовлень,.отримання статистик популярності страв. Використовувати ОС Windows 10, СКБД MSSQL, середовище розробки Microsoft Visual Studio.	
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, опис програмної системи, розробка серверної частини системи, розробка IoT / Smart Device частини системи, розробка веб частини системи, розробка мобільного застосунку системи, висновки, перелік джерел посилань, додатки	
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки	





     КАЛЕНДАРНИЙ ПЛАН
     
     
Номер
Назва етапів курсової роботи
Строк виконання етапів роботи
Примітки
1
Функціональна специфікація
програмного проекту
    22.03.24
виконано
2
Проектування програмного
проекту
    12.04.24
виконано
3
Кодування програмного проекту
    31.05.24
виконано
4
Оформлення пояснювальної
записки
    08.06.24
виконано
5
Захист курсової роботи
    30.06.24
виконано
    
    Дата видачі завдання «26» лютого 2024 р.
Керівник
__________________ доц. Лещинський В.О.
(підпис)
    
    Завдання прийняла до виконання
ст. гр. ПЗПІ-21-2
__________________           Пашньова А. К.
(підпис)




РЕФЕРАТ

     Пояснювальна записка до курсової роботи: 55 с., 18 рис., 3 додатки, 5 джерел.
     ЗАКЛАД ХАРЧУВАННЯ, МЕНЮ, ОНЛАЙН ЗАМОВЛЕННЯ, РОЗУМНА ЛАМПА, СТРАВА, УПРАВЛІННЯ ЗАКЛАДАМИ.
     Об’єктом дослідження є заклади харчування такі, як зокрема ефективність їх управління за допомогою програмних систем. Це охоплює процеси, які забезпечують оптимальне функціонування закладів, а саме, забезпечення швидкого обслуговування клієнтів, оптимізацію процесів замовлення та перегляд наявних столиків і підвищенню рівня задоволеність клієнтів.
     Метою курсової роботи є розробка програмної інформаційної системи, яка призначена для вирішення основних проблем, що виникають у закладах харчування. Система забезпечує зручні інструменти для перегляду меню, оформлення замовлень онлайн, та перегляду доступних столиків через веб-застосунок, а також інтеграцію з мобільним додатком для персоналу і розумними пристроями для покращення якості обслуговування.
     Методи розробки включають використання ASP.NET Web API для серверної частини, MS SQL Server для управління базами даних, ASP.NET MVC для клієнтської частини, .NET MAUI для мобільного застосунку та Arduino ESP32 для інтеграції розумних ламп. Програмна система була розроблена за допомогою таких мов програмування, як C# і C++, а також мови розмітки HTML і CSS. Система використовує асинхронні запити для забезпечення високої продуктивності та ефективного управління запитами.
     У результаті роботи здійснено розробку програмної системи, яка забезпечує комплексне управління закладом харчування. Система сприяє покращенню взаємодії з клієнтами, підвищенню ефективності роботи персоналу і забезпеченню зручного оформлення замовлень і перегляд доступних столиків. Це дозволяє закладам харчування підвищити якість обслуговування і збільшити задоволеність клієнтів.
ЗМІСТ

     
Вступ07
1 ОПИС ПРОГРАМНОЇ СИСТЕМИ08
1.1 Бізнес-вимоги 08
1.1.1 Передумови 08
1.1.2 Бізнес-можливості 09
1.2 Концепція рішень 010
1.2.1 Окреслення концепції рішень 010
1.2.2 Головна функціональність 010
1.3 Рамки та обмеження 011
1.3.1 Рамки первинного випуску 011
1.3.2 Рамки наступних випусків 012
2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ 013
2.1 Моделювання серверної частини програмної системи 013
2.2 Проєктування бази даних 013
2.3 Розробка серверної частини 014
2.3.1 Розробка архітектури системи 014
2.3.2 Програмна розробка серверної частини 015
2.3.3 REST-специфікація017
3 РОЗРОБКА IOT / SMART DEVICE ЧАСТИНИ СИСТЕМИ020
3.1 Моделювання IoT / Smart Device частини системи 020
3.2 Програмна реалізація021
3.2.1 Архітектура IoT / Smart Device частини системи 021
3.2.2 Програмна розробка IoT / Smart Device частини 021
4 РОЗРОБКА ВЕБ ЧАСТИНИ СИСТЕМИ 024
4.1 Моделювання веб частини програмної системи024
4.2 Програмна реалізація веб частини програмної системи 025
4.2.1 Архітектура веб частини 025
4.2.2 Програмна розробка веб частини 026
5 РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ СИСТЕМИ 027
5.1 Моделювання мобільного застосунку програмної системи 027
5.2 Програмна реалізація мобільного застосунку 028
5.2.1 Архітектура мобільного застосунку 028
5.2.2 Програмна розробка мобільного застосунку 029
Висновки030
Перелік джерел посилань031
Додаток А Діаграми і схема033
Додаток Б Програмний код047
Додаток В Звіт перевірки на плагіат 055



ВСТУП


     Індустрія громадського харчування є однією з найбільш динамічних та конкурентних галузей сучасної економіки. Кафе, бари, ресторани та інші заклади харчування відіграють важливу роль у повсякденному житті людей, надаючи їм можливість не лише задовольнити свої потреби у їжі, а й провести час з друзями, родиною чи колегами, відсвяткувати особливі події або просто насолодитися атмосферою закладу [1] . 
     Проте, успіх закладу харчування залежить не лише від якості страв та напоїв, але й від ефективності управління бізнес-процесами та рівня задоволеності клієнтів. Власники та менеджери закладів стикаються з численними викликами, такими як організація роботи персоналу, забезпечення швидкого та якісного обслуговування клієнтів, планування маркетингових кампаній та аналіз їх ефективності. У сучасному цифровому світі, де клієнти все більше покладаються на онлайн-сервіси та мобільні технології, важливим аспектом успіху стає також забезпечення зручного та інтуїтивно зрозумілого інтерфейсу для взаємодії з закладом.
     Розробка та впровадження програмних інформаційних систем, що автоматизують та оптимізують різні аспекти роботи закладів харчування, є актуальним напрямком досліджень та розробок. Такі системи дозволяють підвищити ефективність бізнес-процесів, покращити якість обслуговування клієнтів, зменшити витрати та збільшити прибуток закладу.
     Метою даної курсової роботи є розробка та впровадження комплексної програмної системи, яка дозволить закладам харчування підвищити рівень задоволеності клієнтів шляхом оптимізації та автоматизації ключових бізнес-процесів, забезпечення зручного та ефективного сервісу, а також покращення взаємодії з відвідувачами.
     
     
1 ОПИС ПРОГРАМНОЇ СИСТЕМИ
     1.1 Бізнес вимоги
     1.1.1 Передумови

     
     У сучасному світі майже кожне місто і селище має кафе, бар чи інший заклад харчування. Однак при відкритті такого бізнесу власники часто стикаються з труднощами ефективного управління. Наприклад, у ресторанах високого класу власники можуть мати проблеми з організацією обслуговування великої кількості відвідувачів під час святкових заходів, що може негативно позначитися на репутації закладу.
     Для багатьох відвідувачів також важливі швидкість та якість обслуговування, а також зручність оформлення замовлень і бронювання столиків. Наприклад, відвідувачі фаст-фудів можуть бути незадоволені довгими чергами та повільним обслуговуванням, що призводить до втрати часу та негативного досвіду. У ресторанах з великим меню відвідувачі можуть мати труднощі з вибором страв та оформленням замовлень, що може призвести до помилок та затримок.
     Ця програмна інформаційна система розроблена для вирішення цих та багатьох інших проблем, з якими стикаються заклади харчування. Вона надає їм зручні інструменти для перегляду меню, оформлення замовлень онлайн та перегляд доступних столиків через веб-застосунок, що покращує взаємодію з клієнтами та збільшує кількість замовлень. Для персоналу система пропонує мобільний застосунок, який дозволяє ефективно керувати замовленнями та столиками, що підвищує продуктивність та зменшує час очікування для відвідувачів. Впровадження системи призводить до підвищення ефективності роботи закладу, зростання прибутку та покращення якості обслуговування. Крім того, система забезпечує безпеку та конфіденційність персональних даних клієнтів та інформації про операції закладу, що є важливим аспектом у сучасному цифровому світі.
     1.1.2 Бізнес-можливості
     
     
     Аналіз аналогічних програмних систем «Toast POS» та «Square for Restaurants» виявляє як переваги, так і недоліки кожної з них у порівнянні з «LightServe». «Toast POS» вирізняється простим та зручним інтерфейсом, що полегшує навчання персоналу, а також гнучкими налаштуваннями, що дозволяють адаптувати систему до потреб конкретного бізнесу. Проте, вартість встановлення та підтримки «Toast POS» може бути високою, особливо для невеликих закладів, а інтеграція з іншими системами може виявитися складною.
     «Square for Restaurants» пропонує інтегровану платформу, що об'єднує замовлення онлайн, управління клієнтами та аналітику, що спрощує управління різними аспектами ресторанного бізнесу. Однак, ця система може бути менш гнучкою порівняно з «LightServe», а деякі функції можуть бути обмеженими. Крім того, інтеграція з іншими системами може бути ускладненою.
     Порівняльний аналіз показує, що «LightServe» має потенціал стати більш привабливим та вигідним рішенням для закладів харчування. Завдяки своїй гнучкості та адаптивності, система здатна задовольнити потреби різних типів бізнесів, від невеликих кафе до великих ресторанів. Крім того, очікується, що вартість впровадження та підтримки «LightServe» буде нижчою порівняно з аналогами, що робить її доступнішою для широкого кола підприємців.
     Важливою перевагою «LightServe» є її унікальна модель монетизації, що базується на продажі та підтримці розумних пристроїв, які використовуються для обслуговування відвідувачів та взаємодії з системою. Такий підхід не лише забезпечує додаткове джерело доходу для розробників, але й стимулює власників бізнесу до впровадження інноваційних технологій, що сприяють підвищенню ефективності та прибутковості закладу. 
     
     
     
     1.2 Концепція рішення
     1.2.1 Окреслення концепції
     
     
     Програмна інформаційна система «LightServe» – це інноваційне рішення, призначене для покращення управління закладами харчування. Вона надає власникам закладів комплексний набір інструментів та ресурсів, що дозволяють ефективно керувати певними аспектами бізнесу.
     «LightServe» вирізняється унікальним підходом до управління персоналом, пропонуючи зручний інтерфейс для перегляду столиків в закладі харчування і зміни статусу їх доступності. Система також надає можливість робітникам переглядати доступні замовлення а також змінювати статус їх готовності, тим самим керуючи розумним пристроєм.
     Для клієнтів "LightServe" пропонує інтуїтивно зрозумілий інтерфейс для перегляду меню з детальним описом страв, що спрощує вибір та оформлення замовлень. Крім того, клієнти можуть переглядати доступність столиків у режимі реального часу, що забезпечує зручність та економію часу.
     Однією з ключових особливостей "LightServe" є використання розумних ламп для візуального позначення статусу замовлення. Це інноваційне рішення дозволяє клієнтам бути в курсі готовності своїх страв, що підвищує їх задоволення та покращує загальний досвід відвідування закладу.

     
     1.2.2	Головна функціональність
     
     
     Функціонал для власника (веб-застосунок):
     MF-1: реєстрація закладу харчування;
     MF-2: додавання і видалення робітників у системі;
     MF-3: створення, редагування та видалення меню, а також страв;
     MF-4: відстеження популярності страв, обсягів продажу.
     Функціонал для відвідувача закладу (веб-застосунок):
     MF-5: перегляд меню та акційних пропозицій;
     MF-6: оформлення замовлення онлайн;
     MF-7: перегляд наявності вільних столиків.
     Функціонал для робітника закладу (мобільний застосунок):
     MF-8: вхід в обліковий запис;
     MF-9: перегляд активних та заброньованих столиків, а також відзначання їх доступність;
     MF-10: отримання зроблених онлайн замовлень;
     MF-11: зміна статусу готовності замовлення.
     
     
     1.3 Рамки та обмеження
     1.3.1 Рамки первинного випуску
     
     
     Рамки первинного випуску програмного продукту «LightServe» охоплюють наступну функціональність проєкту.
     Веб-застосунок для власників закладу харчування:
* створення облікового запису закладу харчування;
* управління списком робітників закладу харчування;
* перегляд, створення, редагування та видалення меню, а також страв;
* відстеження популярності страв, обсягів продажу;
* оформлення замовлення онлайн;
* перегляд наявності вільних столиків.
     Мобільний застосунок для робітників:
* перегляд активних та заброньованих столиків, а також відзначання їх доступність;
* отримання зроблених онлайн замовлень;
* зміна статусу готовності замовлення.
     Датчики (розумна лампа):
* відображення статусу готовності замовлення.
     Загальна функціональність:
* поділ за ролями;
* мовна локалізація та інтернаціоналізація;
* забезпечення цілісності та безпеки даних про користувачів.
     
     
     1.3.2	Рамки наступних випусків
     
     
     Рамки наступних випусків програмного продукту «LightServe» передбачають реалізацію наступної функціональності:
* бронювання столиків онлайн;
* отримання звітності щодо ефективності рекламних кампаній;
* додавання акційних пропозицій та спеціальних меню для святкових подій чи особливих випадків.
     Майбутні випуски «LightServe» спрямовані на розширення функціональності та покращення зручності користування.


2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
     2.1 Моделювання серверної частини програмної системи
     
     
     Аби почати створювати серверну частину програмної інформаційної системи для управління закладами харчування «LightServe», варто провести аналіз предметної області. Отже, за допомогою програмної інформаційної системи «LightServe», користувачі, а саме власник закладу харчування зможе зареєструватися і в подальшому авторизуватись в системі, а також додавати, видаляти, змінювати та переглядати інформацію щодо таких сутностей, як: заклад харчування, робітники, меню, страва, столи; робітник, як користувач у свою чергу зможе авторизуватись за допомогою нікнейму та паролю, який надасть йому власник закладу і в подальшому змінити цей пароль, змінювати статус замовлення, змінювати статус столику, отримувати замовлення зроблені онлайн; відвідувач закладу харчування, як користувач зможе зареєструватися і в подальшому авторизуватись в системі, переглянути меню, страви, наявність доступних столиків, а також зробити, редагувати та видаляти замовлення.
     Відповідно до наведеного вище аналізу, було створено діаграми прецедентів для користувачів: робітника (див. рис. А.1) власника закладу харчування (див. рис. А.2) і відвідувача закладу харчування (див. рис. А.3).
     
     
     2.2 Проєктування бази даних


     Аби почати створювати базу даних для програмної інформаційної системи для управління закладами харчування «LightServe», було створено діаграму ER-модель даних (див. рис. А.4). Було створено 9 таблиць, які містять 31 атрибут.
     Визначено, що один власник може мати безліч закладів харчування, в той час як кожен заклад харчування може бути пов'язаний лише з одним власником.
     Також передбачено, що заклад харчування може мати безліч робітників, і, відповідно, один робітник може належати лише одному закладу харчування.
     Визначено, що меню може мати безліч страв, а кожна страва може бути пов'язана лише з одним меню.
     Визначено, що столик може належати одному закладу харчування, а один заклад харчування може мати безліч столиків.
     Зв'язки між стравами та замовленнями в системі визначають, що кожна страва може бути у безлічі замовленнях, і, відповідно, кожне замовлення може містити безліч страв. Створився зв'язок багато до багатьох, тому було створено додатково таблицю Деталі замовлення, яка розділяє цей зв'язок.
     Окрім того, в моделі передбачено структуру для відвідувачів та замовлень. Один відвідувач може створити безліч замовлень, проте одне замовлення стосується одного відвідувача.
     Крім того, у моделі враховано зв'язки між закладом харчування та замовленнями. Один заклад харчування може мати безліч замовлень і одне замовлення може належати одному закладу харчування. 
     У підсумку, ER-модель даних «LightServe» відображає складну структуру взаємозв'язків між власниками, закладами харчування, робітниками, відвідувачами, меню, стравами, столами та замовленнями.

     
     2.3 Розробка серверної частини
     2.3.1 Розробка архітектури системи

     
     Для розробки серверної частини було створено та використано діаграму розгортання, яка є важливою для візуалізації фізичної архітектури системи (див. рис. А.5). Вона дозволяє зрозуміти розташування компонентів та їх зв'язки, що сприяє ефективному проектуванню, аналізу та оптимізації фізичної структури системи. Діаграма розгортання спрощує вивчення взаємодії між компонентами, надаючи повне уявлення про функціональність та залежності.
     Також до діаграми розгортання, була створена ще одна діаграма, а саме діаграма станів для користувачів програмної інформаційної системи «LightServe», а саме: власника (див. рис. А.6), робітника (див. рис. А.7) та відвідувача (див. рис. А.8). Ця діаграма визначає можливі стани системи, події, що можуть спричинити переходи між цими станами, і дії, які відбуваються в кожному стані.
     
     
     2.3.2 Програмна розробка серверної частини


     Для роботи з базами даних було обрано СУБД MS SQL, створено 9 таблиць та створено зв'язки між ними. Для розробки серверної частини було обрано мову програмування С# та технологію ASP.Net Web API.
     Для організації архітектури проєкту файли було поділено за директоріями. Директорія «Controllers» містить контролери, які відповідають за обробку HTTP-запитів і взаємодію з моделями в ASP.Net Web API проекті. Директорія «Database» містить файл LightServeContext, який відповідає за взаємодію з базою даних. «Interfaces» містить інтерфейси, які використовуються для впровадження принципу впровадження залежностей у проекті. Ці інтерфейси визначають контракти між компонентами системи, що сприяє високому рівню розширюваності та підтримує принцип інверсії залежностей. Директорія «Repositories» містить репозиторії, які реалізовують інтерфейси, що розташовані в директорії «Interfaces». Ці репозиторії відповідають за виконання операцій доступу до даних, описаних у відповідних інтерфейсах. Директорія «Models» містить моделі, які визначають структуру та властивості даних, використаних у проекті. Ці моделі служать основою для представлення та обробки інформації в системі, а їхні атрибути відображають характеристики об'єктів, з якими працює програма. Директорія «Resources» містить ресурси для впровадження локалізації на двох мовах: українська та англійська. [2]
     Розглянемо реалізацію деяких моментів у функціональності серверної частини. 
     Реєстрація власника закладу харчування відбувається з використанням його e-mail, який є унікальним для кожного та пароля. Спочатку необхідно перевірити, чи не ввів користувач пустих рядків у поля вводу (див Б.1, рядок 3 ). Далі йде перевірка, чи не існує такого користувача вже у базі даних, якщо так, то виведеться повідомлення, про те що такий користувач вже існує, якщо ні, тоді продовжиться виконання функції реєстрації. Далі відбувається хешування паролю за допомогою бібліотеки BCrypt та методу HashPassword (див Б.1, рядок 12). Після вже створюється екземпляр класу Owner (власник) та за допомогою методу Register додається до бази даних (див Б.1, рядки 14 – 22).
     Авторизація власника закладу харчування відбувається з використанням його e-mail, який є унікальним для кожного та пароля. Спочатку необхідно перевірити, чи не ввів користувач пустих рядків у поля вводу (див Б.2, рядок 3). Далі вже за допомогою методу GetOwner отримуються дані власника та йде перевірка чи існує такий користувач, якщо ні, тоді повертається повідомлення, що не знайдено (див Б.2, рядки 5 – 9), якщо так, тоді за допомогою бібліотеки BCrypt та методу Verify (див Б.2, рядок 12) перевіряється чи є однаковими пароль, який ввід користувач на етапі реєстрації та етапі авторизації. Якщо ні, то виводиться повідомлення (див Б.2, рядок 14), що пароль неправильний, якщо так, тоді користувач успішно авторизується. 
     Реєстрація робітника закладу харчування відбувається таким чином: власник додає робітника у системі і на основі прізвища та імені робітника генерується нікнейм робітника (див Б.3, рядки 8 – 9). Далі йде перевірка чи існує користувач з таким нікнеймом, якщо так тоді до нікнейму додається цифра, починаючи з 1 (див Б.3, рядки 10 – 16). Якщо такого користувача ще не існує далі відбувається генерація пароля за допомогою приватного методу GenerateRandomPassword (див Б.3, рядок 17) розмірами у 12 символів. Далі відбувається хешування паролю за допомогою бібліотеки BCrypt та методу HashPassword (див Б.3, рядок 19). Після вже створюється екземпляр класу Worker (робітник) та за допомогою методу RegisterWorker додається до бази даних (див Б.3, рядки 21 – 30).
     Розгляньмо як працює приватний метод GenerateRandomPassword. Спочатку записано у рядок символи, які дозволено використовувати у паролі. Далі за допомогою класу RNGCryptoServiceProvider для отримання випадкових байтів (див Б.4, рядок 4). Потім створюється масив chars, який заповнюється символами, вибраними за допомогою випадкових байтів зі строки allowedChars (див Б.4, рядки 9 – 12). Результатом є новий рядок, який представляє випадковий пароль, і цей рядок повертається методом.
     
     
     2.3.3 REST-специфікація
     
     
     Запити були створені за принципами REST, який є способом доступу до інформаційних ресурсів через стандартизований підхід. REST використовує принципи інтернету та HTTP для організації системи, щоб забезпечити масштабованість, гнучкість та простоту інтеграції між компонентами.
     Cafe:
* POST /api/Cafe/addCafe - додати новий заклад харчування
* GET /api/Cafe/getAllCafes - отримати всі заклади харчування
* GET /api/Cafe/getCafeById - отримати заклад харчування за ідентифікатором
* DELETE /api/Cafe/deleteCafe - видалити заклад харчування за ідентифікатором
     Customer:
* POST /api/Customer/register - зареєструвати клієнта
* POST /api/Customer/login - авторизувати клієнта
     Dish:
* POST /api/Dish/addDish - додати нову страву
* POST /api/Dish/updateDish - оновити страву
* DELETE /api/Dish/deleteDish - видалити страву
* GET /api/Dish/getPopularDishes - отримати популярні страви
* GET /api/Dish/getDishAmount - отримати кількість страв
     Menu:
* POST /api/Menu/addMenu - додати нове меню
* DELETE /api/Menu/deleteMenu - видалити меню
* GET /api/Menu/getAllMenus - отримати всі меню
* GET /api/Menu/getMenuById - отримати меню за ідентифікатором
     Order:
* GET /api/Order/getAllOrders - отримати всі замовлення
* GET /api/Order/getOrderById - отримати замовлення за ідентифікатором
* POST /api/Order/addOrder - додати нове замовлення
* POST /api/Order/addDishToOrder - додати страву до замовлення
* DELETE /api/Order/deleteOrder - видалити замовлення
* POST /api/Order/changeOrderStatus - змінити статус замовлення
* GET /api/Order/getUndoneOrders - отримати незавершені замовлення
* DELETE /api/Order/deleteDishFromOrder - видалити страву з замовлення
* POST /api/Order/updateDishAmount - оновити кількість страв у замовленні
     Owner:
* POST /api/Owner/register - зареєструвати власника
* POST /api/Owner/login - авторизувати власника
     Table:
* GET /api/Table/getAllTables - отримати всі столи
* POST /api/Table/addTable - додати новий стіл
* POST /api/Table/updateTable - оновити стіл
* DELETE /api/Table/deleteTable - видалити стіл
     Worker:
* POST /api/Worker/registerWorker - зареєструвати працівника
* POST /api/Worker/login - авторизувати працівника
* PUT /api/Worker/resetPassword - скинути пароль працівника
* DELETE /api/Worker/deleteWorker - видалити працівника
* GET /api/Worker/getAllWorkers - отримати всіх працівників
* GET /api/Worker/getWorkerById - отримати працівника за ідентифікатором



3 РОЗРОБКА IOT / SMART DEVICE ЧАСТИНИ СИСТЕМИ
     3.1 Моделювання IoT / Smart Device частини програмної системи
     
     
     Для аналізу та розуміння функціональних можливостей розумної лампи було створено діаграму прецедентів (див. рис. А.9). Ця діаграма дозволяє краще уявити, як саме розумна лампа може бути використана працівником закладу харчування. Основна функціональність полягає у зміні статусу замовлення, що має відображатися через зміну кольору лампи. Наприклад, якщо замовлення готове до видачі, лампа світить зеленим, щоб інформувати клієнтів. У протилежному випадку, коли замовлення ще не готове, лампа світить червоним. Діаграма прецедентів зображує відношення між акторами та прецедентами системи.
     Розгляньмо UML діаграму діяльності (див. рис. А.10), яка надає подробиці щодо конкретних дій, які відбуваються як на пристрої, так і на серверній частині під час виконання певних функцій. Вона допомагає розібратися в тому, як саме пристрої взаємодіють між собою та які кроки необхідно виконати для коректної роботи системи.
     Додатково до попередніх діаграм було підготовлено діаграму станів (див. рис. А.11), що відображає різні стани, у яких може перебувати розумна лампа та переходи між цими станами в залежності від зовнішніх подій. Ця діаграма важлива для розуміння роботи лампи на рівні її внутрішньої логіки та алгоритмів.
     Взаємодія програмного забезпечення з іншими частинами системи буде відбуватися через серверну частину, до якої було додано додаткові методи: отримання повної інформації про замовлення, а також зміна статусу готовності замовлення працівником закладу харчування. 
     В якості прикладу взаємодії було створено діаграму взаємодії (див. рис. А.12). Ця діаграма детально описує послідовність дій, які відбуваються під час взаємодії пристрою з Wi-Fi та сервером. Після успішного підключення до мережі, пристрій отримує дані про статус замовлення з сервера, які впливають на колір лампи.
     
     
     3.2 Програмна реалізація
     3.2.1 Архітектура IoT / Smart Device частини програмної системи
     
     
     Було використано мову  програмування С++, а також віртуальне середовище Wokwi для написання програмного забезпечення для SmartDevice пристрою. Для емуляції реальної системи використовувався мікроконтролер Arduino ESP32, який має можливість підключення до мережі і доступу до Інтернету, що є необхідним для взаємодії з серверною частиною. [3]
     У програмі використовуються HTTP-запити для отримання даних з серверу, а також бібліотека ArduinoJson для обробки відповідей від сервера.
     
     
     3.2.2 Програмна розробка IoT / Smart Device частини
     
     
     Перед тим як розпочати написання програмного коду, було створено схему фізичного розміщення компонентів системи: мікроконтролера та двох світлодіодів (див. рис. А.13).
     Мікроконтролер ESP32 виступає як центральний пристрій. Він відповідає за виконання програмного коду та управління всією системою. Поодинокі світлодіоди використовуються для візуального відображення стану системи. Червоний світлодіод сигналізує про неготовність замовлення, тоді як зелений – про його готовність. Додатково, у схемі присутні два резистори, які служать для обмеження потоку струму, що подається до світлодіодів. Це необхідно для захисту світлодіодів від можливого перевищення струму, що може спричинити їх пошкодження.
     Принцип роботи полягає у тому, що мікроконтролер ESP32 керує роботою світлодіодів через резистори. Залежно від вимог програми, він може вмикати або вимикати світлодіоди. Наприклад, якщо програма вказує на неготовність замовлення, ESP32 активує червоний світлодіод для відображення цього стану, а якщо замовлення готове, то активує зелений світлодіод. Після створення схеми починається написання програмного коду. Спочатку оголошуються глобальні змінні, які повинні бути доступні в усіх частинах програми. Це змінні, які визначають ім'я та пароль мережі Wi-Fi; константа, яка визначає частоту виконання певної дії; змінна, яка зберігає час в мілісекундах з моменту останнього виконання дії. Також є змінні, які вказують на номери виводів мікроконтролера ESP32, до яких підключені світлодіоди зеленого та червоного кольорів відповідно.
     В методі setup() відбувається налаштування системи. Встановлюється з'єднання з мережею Wi-Fi за допомогою введених раніше ім'я мережі та паролю. Потім відбувається очікування підключення до мережі, під час якого виводиться символ "." на монітор серійного порту кожні 100 мілісекунд. Після успішного підключення виводиться повідомлення «WiFi Connected!» разом з локальною IP-адресою мікроконтролера. На останньому кроці встановлюється режим виводу для виводів, до яких підключені світлодіоди (див. рядки 11 – 12).
      1 void setup(){
      2 	Serial.begin(115200);
      3  	WiFi.begin(ssid, pass);
      4  	while(WiFi.status() != WL_CONNECTED){
      5    		delay(100);
      6    		Serial.println(".");
      7  	}
      8  	Serial.println("WiFi Connected!");
      9  	Serial.println(WiFi.localIP());
      10
      11  	pinMode(greenLedPin, OUTPUT);
      12  	pinMode(redLedPin, OUTPUT);
      13 }
     
     У функції loop() виконується кілька дій. Спочатку визначається поточний час у мілісекундах (див. Б.5 рядок 3). Потім проводиться порівняння з попереднім часом, щоб визначити, чи минув певний інтервал часу. Якщо це так, виконується HTTP-запит до веб-сервера за допомогою методу GET (див.  Б.5 рядки 7 – 9). Отримана відповідь аналізується, і з неї витягується значення властивості «isDone» (див. Б.5 рядок 15). Залежно від цього значення керується станом світлодіодів (див. Б.5 рядки 17 – 26). Якщо замовлення завершено, вмикається зелений світлодіод (див. Б.5 рядки 19 – 20), в іншому випадку – червоний (див. Б.5 рядки 24 – 25). У разі помилки виконання HTTP-запиту виводиться відповідне повідомлення (див. Б.5 рядки 28 – 31). На останньому кроці з'єднання з веб-сервером завершується.


4 РОЗРОБКА ВЕБ ЧАСТИНИ СИСТЕМИ
     4.1 Моделювання веб частини програмної системи


     Аби почати створювати клієнтську частину програмної інформаційної системи для управління закладами харчування «LightServe», варто провести аналіз предметної області. Отже, за допомогою програмної інформаційної системи «LightServe», користувачі, а саме власник закладу харчування зможе авторизуватись в системі, а також додавати, видаляти, змінювати та переглядати інформацію щодо таких сутностей, як: заклад, робітники в закладі, меню, страви, столики. Також користувачем даної системи є відвідувач закладу харчування, який зможе зареєструватися і в подальшому авторизуватись в системі, а також переглядати меню, страви, оформлювати замовлення та переглядати наявність вільних столиків у закладах.
     Відповідно до наведеного вище аналізу, було створено діаграми прецедентів для користувачів: власника (див. рис. А.2) та відвідувача закладу харчування (див. рис. А.3). 
     Клієнтська частина буде взаємодіяти з серверною частиною програмної системи за допомогою запитів HTTP. Запити HTTP, які буде надсилати клієнт, включатимуть різноманітні дії, такі як отримання інформації, надсилання даних для обробки чи виконання конкретного завдання. Було створено діаграму компонентів (див. рис А.14), аби краще зрозуміти архітектурну структуру та взаємозв'язок між різними компонентами програмної системи. На діаграмі компонентів будуть відображені основні модулі, які складають клієнтську частину системи, а також їхні взаємодії.
     
     
     
     
     
     4.2 Програмна реалізація веб частини програмної системи
     4.2.1 Архітектура веб частини
     
     
     Клієнтська частина програми була розроблена на мові програмування C# з використанням технології розробки ASP.NET MVC. У цій архітектурі моделі представлені класами, які раніше використовувалися у серверній частині, такі як класи об'єктів (заклад харчування, відвідувач, страва, меню, замовлення, деталі замовлення, власник, столик, робітник).
     В якості представлення (View) використовуються стандартні HTML-файли, в яких поєднано HTML та C# (розширення .cshtml). Для реалізації дизайну використовується бібліотека Bootstrap. Контролери, які є файли з кодом C#, використовуються для створення та відображення сторінок, а також для здійснення запитів до серверної частини програмної системи.
     Система підтримує локалізацію англійською та українською мовами. Для цього було створено два файли ресурсів, які містять текст у вигляді ключ-значення для використання відповідного мовного варіанту.
     Також було створено ще одну діаграму, а саме діаграму станів для користувачів програмної інформаційної системи «LightServe», а саме: власника (див. рис. А.7) та відвідувача закладу харчування (див. рис. А.8). Ця діаграма визначає можливі стани системи, події, що можуть спричинити переходи між цими станами, і дії, які відбуваються в кожному стані.
     Також було створено діаграму діяльностей для авторизації (див. рис. А.15) та роботи власника у системі (див. рис. А.16), яка візуально відображає послідовність операцій та взаємодію між різними етапами процесу аутентифікації та використання функціоналу системи.
     
     
     
     
     4.2.2 Програмна розробка веб частини
     
     
     Розглянемо реалізацію деяких моментів у функціональності серверної частини [4]. Реєстрація відвідувача закладу харчування відбувається з використанням його e-mail, який є унікальним для кожного та пароля. Спочатку необхідно перевірити, чи не ввів користувач пустих рядків у поля вводу (див Б.6, рядок 3 ). Далі йде взаємодія з сервером: створюється POST запит до API для реєстрації відвідувача (див Б.6, рядки 5 – 11). Після отримання відповіді від сервера, йде обробка запиту, оскільки дані повертаються у форматі JSON. Далі перевіряється яка відповідь прийшла від сервера (див Б.6, рядки 12 – 24), якщо запит був успішним, то обробляється успішний відгук, включаючи оновлення інформації про відвідувача та перенаправлення на домашню сторінку. У випадку невдачі відгуку обробляються повідомлення про помилку. Якщо була помилка при валідації, тоді повертається вид реєстрації з передачею моделі. Це дозволяє виводити повідомлення про помилки користувачеві та зберігати введені дані.
     Авторизація відвідувача закладу харчування відбувається з використанням його e-mail, який є унікальним для кожного та пароля. Спочатку необхідно перевірити, чи не ввів користувач пустих рядків у поля вводу (див Б.7, рядок 3). Далі йде взаємодія з сервером: використовується HttpClient для взаємодії з сервером; здійснюється POST-запит до API для авторизації відвідувача, передаючи дані у форматі JSON (див Б.7, рядки 5 – 19). Далі перевіряється яка відповідь прийшла від сервера (див Б.7, рядки 21 – 35), якщо запит був успішним, то обробляється успішний відгук, включаючи оновлення інформації про відвідувача та перенаправлення на домашню сторінку. У випадку невдачі відгуку обробляються повідомлення про помилку. Якщо була помилка при валідації, тоді повертається вид авторизації з передачею моделі (див Б.7, рядок 38). Це дозволяє виводити повідомлення про помилки користувачеві та зберігати введені дані.


5 РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ СИСТЕМИ
     5.1 Моделювання мобільного застосунку програмної системи
     
     
     Аби почати створювати мобільний застосунок для програмної інформаційної системи для управління закладами харчування «LightServe», варто провести аналіз предметної області. Отже, за допомогою програмної інформаційної системи «LightServe», користувачі, а саме робітник зможе авторизуватись за допомогою нікнейму та паролю, який надасть йому адміністратор і в подальшому змінити цей пароль, переглядати список столиків в закладі харчування, змінювати їм статус на доступний або не доступний, аби в подальшому відвідувачі закладу харчування могли це відстежувати через веб застосунок, переглядати всі замовлення які надходять від відвідувачів та змінювати їм статус готовності, тим самим керуючи розумною лампою, а також переглядати деталі конкретного замовлення.
     Відповідно до наведеного вище аналізу, було створено діаграму прецедентів для користувача: робітника закладу харчування (див. рис. А.1). 
     Мобільний застосунок буде взаємодіяти з серверною частиною програмної системи за допомогою запитів HTTP. Запити HTTP, які буде надсилати клієнт, включатимуть різноманітні дії, такі як отримання інформації, надсилання даних для обробки чи виконання конкретного завдання. Було створено діаграму компонентів (див. рис А.17), аби краще зрозуміти архітектурну структуру та взаємозв'язок між різними компонентами програмної системи. На діаграмі компонентів будуть відображені основні модулі, які складають мобільний застосунок системи, а також їхні взаємодії.
     
     
     
     
     
     5.2 Програмна реалізація мобільного застосунку
     5.2.1 Архітектура мобільного застосунку
     
     
     Мобільний застосунок був розроблений на мові програмування C# з використанням технології розробки .NET MAUI. У цій архітектурі моделі представлені класами, які раніше використовувалися у серверній частині, такі як класи об'єктів (заклад харчування, відвідувач, страва, меню, замовлення, деталі замовлення, власник, столик, робітник).
     В якості представлення (View) використовуються стандартні XAML-файли. Основна логіка та взаємодія з сервером знаходиться у файлах з розширенням .xaml.cs. Для кожної сторінки створено окремі файли.
     Система підтримує локалізацію англійською та українською мовами. Для цього було створено два файли ресурсів, які містять текст у вигляді ключ-значення для використання відповідного мовного варіанту.
     Також було створено ще одну діаграму, а саме діаграму станів для користувача програмної інформаційної системи «LightServe» (див. рис. А.7). Ця діаграма визначає можливі стани системи, події, що можуть спричинити переходи між цими станами, і дії, які відбуваються в кожному стані.
     Також було створено діаграму діяльностей для авторизації та роботи користувача у системі (див. рис. А.18), яка деталізує послідовність кроків, які виконує користувач під час авторизації в системі та подальшої роботи з нею. Ця діаграма включає такі дії, як введення імені користувача та паролю, перевірка коректності введених даних, перехід до головного меню, вибір функцій системи. Діаграма діяльностей дозволяє виявити зайві або недостатні кроки в процесі взаємодії з користувачем, а також оптимізувати інтерфейс системи для забезпечення максимальної зручності та ефективності використання.
     Створення та аналіз діаграм станів та діяльностей є важливим етапом розробки програмної системи «LightServe». Вони дозволяють розробникам краще зрозуміти потреби користувачів, виявити потенційні проблеми та розробити ефективні рішення для їх усунення. 
     
     
     5.2.2 Програмна розробка мобільного застосунку
     
     
     Розглянемо реалізацію деяких моментів у функціональності серверної частини [5]. 
     Метод ChangeOrderStatus відповідає за зміну статусу замовлення на основі взаємодії користувача з інтерфейсом. Метод викликається, коли натискається кнопка, і приймає об'єкт sender та параметри події EventArgs. Спочатку відбувається отримання кнопки, яка викликала подію, та зв'язане з нею замовлення (див. рис Б.8 рядки 3-4). Потім, у межах блоку try, створюється об'єкт HttpClient, який дозволяє здійснити HTTP-запит до сервера (див. рис. Б.8 рядок 7). Вказується базова адреса сервера, до якого будуть відправлені HTTP-запити (див. рис. Б.8 рядок 8).
     Здійснюється асинхронний POST-запит до вказаного API для зміни статусу замовлення на основі його ідентифікатора. Новий статус визначається шляхом інверсії поточного статусу (див. рис Б.8 рядки 10 – 11). Далі йде перевірка, чи запит був виконаний успішно (див. рис Б.8 рядки 13 – 21). Якщо запит успішний, статус відповідного замовлення в колекції оновлюється, після чого колекція прив'язується до інтерфейсу користувача для оновлення відображення (див. рис Б.8 рядки 15 – 19). Якщо запит не успішний, відображається повідомлення про помилку із зазначенням причини невдачі (див. рис Б.8 рядки 20 – 21). У разі виникнення будь-яких виключень у процесі виконання запиту, вони обробляються у блоці catch, і користувач отримує повідомлення з деталями помилки (див. рис Б.8 рядки 23 – 25). 
     Метод OnChangeClicked відповідає за зміну пароля користувача при натисканні кнопки. Метод приймає параметри sender та EventArgs, які використовуються для обробки події натискання (див. рис Б.9 рядок 2).
     Спочатку зчитуються старий та новий паролі з відповідних текстових полів OldPassoword і NewPasswordEntry (див. рис Б.9 рядки 3 – 4). Далі перевіряється, чи не є ці поля порожніми або складаються з пробілів. Якщо обидва поля містять дані, створюється об'єкт WorkerMobileDto, який включає ім'я користувача, старий пароль та новий пароль (див. рис Б.9 рядки 6 – 11). Далі  створюється об'єкт HttpClient для здійснення HTTP-запиту до сервера (див. рис Б.9 рядок 13). Вказується базова адреса сервера і встановлюються заголовки запиту, щоб приймати відповіді у форматі JSON (див. рис Б.9 рядки 14 – 16). Здійснюється асинхронний PUT-запит до вказаного API для зміни пароля користувача, передаючи об'єкт workerDto як дані запиту (див. рис Б.9 рядок 18). Далі йде перевірка, чи запит був виконаний успішно (див. рис Б.9 рядки 20 – 25). Якщо запит успішний, відображається повідомлення про успішну зміну пароля і здійснюється повернення до попередньої сторінки навігації (див. рис Б.9 рядки 
21 – 23). Якщо запит не успішний, відображається повідомлення про помилку з інформацією про те, що робітника не знайдено (див. рис Б.9 рядок 25).


ВИСНОВКИ

     
     На основі аналізу потреб закладів харчування та їхніх клієнтів, а також вивчення наявних рішень на ринку, було розроблено комплексну програмну інформаційну систему «LightServe». Система включає в себе веб-застосунок для клієнтів та власників закладу харчування, мобільний застосунок для персоналу та інтеграцію з розумними лампами, що дозволяє автоматизувати та оптимізувати ключові бізнес-процеси в закладах харчування.
     Розроблений веб-застосунок надає клієнтам зручний інструмент для перегляду меню, оформлення замовлень онлайн та перегляд доступних столиків, що сприяє підвищенню їх задоволеності та лояльності. Мобільний застосунок для персоналу забезпечує ефективне управління замовленнями та столиками, покращує комунікацію між кухнею та залом, а також дозволяє персоналу швидше реагувати на потреби клієнтів. Інтеграція з розумними лампами надає клієнтам візуальну інформацію про статус їхнього замовлення, що підвищує рівень сервісу та створює додатковий комфорт.
     Завдяки впровадженню системи «LightServe», заклади харчування отримують можливість підвищити ефективність роботи, покращити якість обслуговування, збільшити кількість замовлень та залучити нових клієнтів. Система також сприяє оптимізації витрат на персонал та ресурси, що позитивно впливає на прибутковість бізнесу. Таким чином, «LightServe» є ефективним інструментом для підвищення конкурентоспроможності закладів харчування в сучасних умовах ринку.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

     
1. The impact of online ordering systems on the restaurant industry. Retail Insider. URL: https://retail-insider.com/articles/2024/02/the-impact-of-online-ordering-systems-on-the-restaurant-industry/ (дата звернення: 16.03.2024).
2. Мартін Р. С. Чиста архітектура. Фабула, 2019. 368 с.
3. ESP32 simulation | wokwi docs. Welcome to Wokwi! | Wokwi Docs. URL: https://docs.wokwi.com/guides/esp32 (дата звернення: 22.04.2024).
4. C# Guide - .NET managed language. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/dotnet/csharp/ (дата звернення: 02.04.2024).
5. .NET multi-platform app UI (.NET MAUI) | .NET. Microsoft. URL: https://dotnet.microsoft.com/en-us/apps/maui (дата звернення: 17.05.2024).
6. Посилання на проєкт у симуляторі Wokwi: 
https://wokwi.com/projects/396082703140468737
7. Посилання на відеоматеріали реалізованого проєкту: https://youtu.be/pMXCTUrw4eU
8. Посилання на програмний код:
https://github.com/NurePashnovaAnastasiia/apzkr-pzpi-21-2-pashnova-anastasiia




ДОДАТОК А
Діаграми та схема



Рисунок А.1 – UML діаграма прецедентів для робітника


Рисунок А.2 – UML діаграма прецедентів для власника


Рисунок А.3 – UML діаграма прецедентів для відвідувача


Рисунок А.4 – ER-модель даних діаграма


Рисунок А.5 – Діаграма розгортання


Рисунок А.6 – Діаграма станів для власника  

Рисунок А.7 – Діаграма станів для робітника

Рисунок А.8 – Діаграма станів для відвідувача



Рисунок А.9 – UML діаграма прецедентів


Рисунок А.10 – UML діаграма діяльності


Рисунок А.11 – UML діаграма станів


Рисунок А.12 – UML діаграма взаємодії


Рисунок А.13 – Схема фізичного розміщення компонентів системи


Рисунок А.14 – UML діаграма компонентів


Рисунок А.15 – UML діаграма діяльностей авторизації

Рисунок А.16 – UML діаграма діяльностей роботи користувача у системі


Рисунок А.17 – UML діаграма компонентів


Рисунок А.18 – UML діаграма діяльностей


ДОДАТОК Б
Програмний код


     Б.1 Метод реєстрація власника закладу харчування


1        public async Task<ActionResult<Owner>> Register(OwnerDto request)
2        {
3            if (!string.IsNullOrWhiteSpace(request.Email) && !string.IsNullOrWhiteSpace(request.Password))
4            {
5                var ownerExists = await _ownerRepository.OwnerExists(request.Email);
6                if (ownerExists)
7                {
8                    return BadRequest("User with this email is already exist");
9                }
10                else
11                {
12                    string passwordHash = BCrypt.Net.BCrypt.HashPassword(request.Password);
13
14                    var owner = new Owner
15                    {
16                        Email = request.Email,
17                        Password = passwordHash,
18                        Surname = request.Surname,
19                        Name = request.Name
20                    };
21
22                     if (await _ownerRepository.Register(owner))
23                    {
24                        return Ok(owner);
25                    }
26                }
27            }
28            return BadRequest(_stringLocalizer[SharedResourcesKeys.Invalid]);
29        }


     Б.2 Метод авторизації власника закладу харчування


1        public async Task<ActionResult<Owner>> Login(OwnerDto request)
2        {
3            if (!string.IsNullOrWhiteSpace(request.Email) && !string.IsNullOrWhiteSpace(request.Password))
4            {
5                var owner = await _ownerRepository.GetOwner(request.Email);
6                if (owner == null)
7               {
8                   return NotFound(_stringLocalizer[SharedResourcesKeys.NotFound]);
9               }
10                else
11                {
12                   if (!BCrypt.Net.BCrypt.Verify(request.Password, owner.Password))
13                    {
14                        return BadRequest(_stringLocalizer[SharedResourcesKeys.WrongPassword]);
15                    }
16                    owner.Password = "";
17                   return Ok(owner);
18                }
19            }
20            return BadRequest(_stringLocalizer[SharedResourcesKeys.Invalid]);
21        }


     Б.3 Метод реєстрації робітника закладу харчування


1        public async Task<ActionResult<Worker>> RegisterWorker(WorkerDto request, int cafeId)
2        {
3            if (!string.IsNullOrWhiteSpace(request.Name) && !string.IsNullOrWhiteSpace(request.Surname) && farmId > 0)
4           {
5                var cafe = await _cafeRepository.GetCafeById(cafeId);
6                if(cafe != null)
7.                {
8                    string baseUsername = (request.Name + "." + request.Surname).ToLower();
9                    string username = baseUsername;
10                    int counter = 1;
11
12                    while (await _workerRepository.WorkerExists(username))
13                    {
14                        username = $"{baseUsername}{counter}";
15                       counter++;
16                    }
17                   string password = GenerateRandomPassword();
18
19                    string passwordHash = BCrypt.Net.BCrypt.HashPassword(password);
20
21                    var worker = new Worker
22                    {
23                        Password = passwordHash,
24                        Surname = request.Surname,
25                        Name = request.Name,
26                        Username = username,
27                        Cafe = cafe,
28                        CafeId = cafeId
29                    };
30                    var registeredWorker = await _workerRepository.RegisterWorker(worker);
31                   registeredWorker.Password = password;
32                    return Ok(registeredWorker);
33               }
34
35               return NotFound(_stringLocalizer[SharedResourcesKeys.NotFound]);
36            }
37            return BadRequest(_stringLocalizer[SharedResourcesKeys.Invalid]);
38        }


     Б.4 Метод генерації випадкового паролю


1        private string GenerateRandomPassword()
2        {
3            const string allowedChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_+=<>?";
4            using (var rng = new RNGCryptoServiceProvider())
5            {
6                byte[] randomBytes = new byte[12];
7                rng.GetBytes(randomBytes);
8                char[] chars = new char[randomBytes.Length];
9                for (int i = 0; i < randomBytes.Length; i++)
10                {
11                    chars[i] = allowedChars[randomBytes[i] % allowedChars.Length];
12                }
13                return new string(chars);
14            }
15        }


     Б.5 Функція для виконання основної роботи програми


1 void loop()
2 {
3  unsigned long currentMillis = millis();
4  if (currentMillis - previousMillis > interval)
5  {
6    previousMillis = currentMillis;
7    HTTPClient http;
8    http.begin ("https://lightservewebapi20240424185555.azurewebsites.net/api/Order/getOrderById?orderId=1");
9    int httpResponseCode = http.GET();
10    if (httpResponseCode > 0)
11    {
12      String payload = http.getString();
13      DynamicJsonDocument doc(1024);
14      deserializeJson(doc, payload);
15      bool isDone = doc["isDone"];
16      Serial.print(isDone);
17      if (isDone)
18      {
19        digitalWrite(greenLedPin, HIGH);
20        digitalWrite(redLedPin, LOW);
21      }
22      else
23      {
24        digitalWrite(greenLedPin, LOW);
25        digitalWrite(redLedPin, HIGH);
26      }
27    }
28    else
29    {
30      Serial.print("HTTP request failed with error code: ");
31      Serial.println(httpResponseCode);
32    }
33    http.end();
34  }
35 }


     Б.6 Метод реєстрація відвідувача закладу харчування


1        public async Task<IActionResult> Register(UserDto model)
2        {
3            if (ModelState.IsValid)
4            {
5                using (var client = new HttpClient())
6                {
7                    var registerEndpoint = "api/Customer/register";
8                    client.BaseAddress = new Uri(Baseurl);
9                    client.DefaultRequestHeaders.Clear();
10                    client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
11                    HttpResponseMessage response = await client.PostAsJsonAsync(registerEndpoint, model);
12                    if (response.IsSuccessStatusCode)
13                    {
14                        var empResponse = response.Content.ReadAsStringAsync().Result;
15                        _user.IsAuthorized = true;
16                       _user.IsOwner = false;
17                        _user.Email = model.Email;
18                        return RedirectToAction("Index", "Home");
19                    }
20                    else
21                    {
22                        var errorResponse = await response.Content.ReadAsStringAsync();
23                        ModelState.AddModelError("", errorResponse);
24                    }
25                }
26            }
27            return View(model);
28        }


     Б.7 Метод авторизації відвідувача закладу харчування


1        public async Task<IActionResult> Login(UserDto model)
2        {
3            if (ModelState.IsValid)
4            {
5                string registerEndpoint;
6                using (var client = new HttpClient())
7                {
8                    if (model.Email == ownerEmail)
9                    {
10                        registerEndpoint = "api/Owner/login";
11                   }
12                    else
13                    {
14                        registerEndpoint = "api/Customer/login";
15                    }
16                    
17                    client.BaseAddress = new Uri(Baseurl);
18                    client.DefaultRequestHeaders.Clear();
19                    client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
20                    HttpResponseMessage response = await client.PostAsJsonAsync(registerEndpoint, model);
21                    if (response.IsSuccessStatusCode)
22                    {
23                        _user.IsAuthorized = true;
24                        _user.Email = model.Email;
25                        if (model.Email == "ap@gmail.com")
26                        {
27                            _user.IsOwner = true;
28                        }
29                        else
30                        {
31                            _user.IsOwner = false;
32                        }
33                        return RedirectToAction("Index", "Home");
34                    }
35                    else
36                    {
37                        var errorResponse = await response.Content.ReadAsStringAsync();
38                        ModelState.AddModelError("", errorResponse);
39                    }
40                }
41            }
42            return View(model);
43        }


     Б.8 Метод зміни статусу замовлення


1    private async void ChangeOrderStatus(object sender, EventArgs e)
2    {
3        var button = (Button)sender;
4        var order = (Order)button.BindingContext;
5        try
6        {
7            using (HttpClient client = new HttpClient())
8            {
9                client.BaseAddress = new Uri(BaseApiUrl);
10                var response = await client.PostAsJsonAsync($"api/Order/changeOrderStatus?orderId={order.Id}", !order.IsDone);
11                if (response.IsSuccessStatusCode)
12                {
13                    int index = Orders.IndexOf(order);
14                    if (index != -1)
15                    {
16                        Orders[index].IsDone = !order.IsDone;
17                        TaskCollectionView.ItemsSource = null;
18                        TaskCollectionView.ItemsSource = Orders;
19                    }
20                }
21                else
22                {
23                    await DisplayAlert("Error", $"Failed to change order status: {response.ReasonPhrase}", "OK");
24                }
25            }
26        }
27        catch (Exception ex)
28        {
29            await DisplayAlert("Error", $"An error occurred: {ex.Message}", "OK");
30        }
31    }


     Б.9 Метод обробки кліка на кнопку «Змінити пароль»


1    public async void OnChangeClicked(object sender, EventArgs e)
2    {
3        string oldPassword = OldPassoword.Text;
4        string newPassword = NewPasswordEntry.Text;
5
6        if (!string.IsNullOrWhiteSpace(oldPassword) && !string.IsNullOrWhiteSpace(newPassword))
7        {
8            var workerDto = new WorkerMobileDto()
9            {
10                Username = loggedInUsername,
11                OldPassword = oldPassword,
12                Password = newPassword,
13            };
14
15            using (var client = new HttpClient())
16            {
17                var registerEndpoint = "api/Worker/resetPassword";
18
19                client.BaseAddress = new Uri(Baseurl);
20                client.DefaultRequestHeaders.Clear();
21                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
22
23                HttpResponseMessage response = await client.PutAsJsonAsync(registerEndpoint, workerDto);
24
25                if (response.IsSuccessStatusCode)
26                {
27                    await DisplayAlert("Успіх", "Пароль успішно змінено", "OK");
28                    await Navigation.PopAsync();
29                }
30                else
31                {
32                    await DisplayAlert("Помилка", "Робітника не знайдено", "OK");
33                }
34            }
35        }
36        else
37        {
38            await DisplayAlert("Помилка", "Старий пароль та новий пароль не можуть бути пустими полями", "OK");
39        }
40    }


ДОДАТОК В
Звіт перевірки на плагіат
30




